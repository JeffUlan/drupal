<?php

/**
 * @file
 * Tests for Configuration module.
 */

use Drupal\Core\Config\SignedFileStorage;

/**
 * Tests the secure file writer.
 */
class ConfigFileSecurityTestCase extends DrupalWebTestCase {
  protected $profile = 'testing';

  protected $filename = 'foo.bar';

  protected $testContent = 'Good morning, Denver!';

  public static function getInfo() {
    return array(
      'name' => 'File security',
      'description' => 'Tests security of saved configuration files.',
      'group' => 'Configuration',
    );
  }

  /**
   * Tests that a file written by this system has a valid signature.
   */
  function testFileVerify() {
    $file = new SignedFileStorage($this->filename);
    $file->write($this->testContent);

    $this->assertTrue($file->verify(), 'A file verifies after being written.');

    unset($file);

    // Load the file again, so that there is no stale data from the old object.
    $file = new SignedFileStorage($this->filename);
    $this->assertTrue($file->verify(), 'A file verifies after being written and reloaded.');
  }

  /**
   * Tests that a file written by this system can be successfully read back.
   */
  function testFilePersist() {
    $file = new SignedFileStorage($this->filename);
    $file->write($this->testContent);

    unset($file);

    // Reading should throw an exception in case of bad validation.
    // Note that if any other exception is thrown, we let the test system
    // handle catching and reporting it.
    try {
      $file = new SignedFileStorage($this->filename);
      $saved_content = $file->read();

      $this->assertEqual($saved_content, $this->testContent, 'A file can be read back successfully.');
    }
    catch (Exception $e) {
      $this->fail('File failed verification when being read.');
    }
  }

  /**
   * Tests that a file fails validation if it's been monkeyed with.
   */
  function testFileNotVerify() {
    $file = new SignedFileStorage($this->filename);
    $file->write($this->testContent);

    // Manually overwrite the body of the secure file. Note that we skip the
    // first line, which is reserved for the signature and such, to overwrite
    // just the payload.
    $raw_file = new SplFileObject($file->getFilePath(), 'a+');
    $raw_file->fwrite('Good morning, Detroit!');
    $raw_file->fflush();
    unset($raw_file);

    unset($file);

    $file = new SignedFileStorage($this->filename);
    $this->assertFalse($file->verify(), 'Corrupted file does not verify.');
  }
}

/**
 * Tests reading and writing file contents.
 */
class ConfigFileContentTestCase extends DrupalWebTestCase {
  protected $profile = 'testing';

  protected $fileExtension = 'xml';

  public static function getInfo() {
    return array(
      'name' => 'File content',
      'description' => 'Tests reading and writing of configuration files.',
      'group' => 'Configuration',
    );
  }

  /**
   * Tests setting, writing, and reading of a configuration setting.
   */
  function testReadWriteConfig() {
    $config_dir = config_get_config_directory();
    $name = 'foo.bar';
    $key = 'foo';
    $value = 'bar';

    // Attempt to read non-existing configuration.
    $config = config($name);
    // Verify an configuration object is returned.
//    $this->assertEqual($config->name, $name);
    $this->assertTrue($config);
    // Verify the configuration object is empty.
    $this->assertEqual($config->get(), array());
    // Verify nothing was saved.
    $db_config = db_query('SELECT * FROM {config} WHERE name = :name', array(':name' => $name))->fetch();
    $this->assertIdentical($db_config, FALSE);
    $this->assertFalse(file_exists($config_dir . '/' . $name . '.' . $this->fileExtension));

    // Save the configuration.
    $config = config($name);
    $config->set($key, $value);
    $config->save();
    // Verify the database entry exists.
    $db_config = db_query('SELECT * FROM {config} WHERE name = :name', array(':name' => $name))->fetch();
    $this->assertEqual($db_config->name, $name);
    // Verify the file exists.
    $this->assertTrue(file_exists($config_dir . '/' . $name . '.' . $this->fileExtension));

    // Read the configuration.
    $config = config($name);
//    $this->assertEqual($config->name, $name);
    $this->assertTrue($config);
    $this->assertEqual($config->get($key), $value);

    // Delete the configuration.
    $config = config($name);
    $config->delete();
    // Verify the database entry no longer exists.
    $db_config = db_query('SELECT * FROM {config} WHERE name = :name', array(':name' => $name))->fetch();
    $this->assertIdentical($db_config, FALSE);
    $this->assertFalse(file_exists($config_dir . '/' . $name . '.' . $this->fileExtension));

    // Attempt to delete non-existing configuration.
    // Write and read an array value.
    // Add an array value to a nested key.
    // Type casting into string.
    // NULL value behavior.
    // List config names by prefix.
  }
}
